<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8">
  <title>Conferma Ordine</title>
  <link rel="stylesheet" href="css/style.css">
  <style>
    .box { padding: 12px; border: 1px solid #ddd; border-radius: 10px; margin: 10px 0; }
    .ok { color: green; }
    .err { color: #b00020; }
  </style>
</head>
<body>
  <h1>âœ… Ordine Confermato</h1>
  <h2>Grazie per il tuo ordine!</h2>

  <div id="riepilogo" class="box"></div>
  <div id="tempo-attesa" class="box"></div>

  <h3>ðŸ›’ Piatti ordinati:</h3>
  <ul id="lista-piatti" class="box"></ul>

  <p><a href="index.html">ðŸ”™ Torna alla Home</a></p>

<script>
window.onload = async () => {
  const isLocal = location.hostname === "localhost" || location.hostname === "127.0.0.1";
  const API_BASE = isLocal
    ? "http://localhost:3000"
    : "https://restaurant-management-wzhj.onrender.com";

  const ordine = JSON.parse(localStorage.getItem("lastConfirmedOrder"));
  const riepilogo = document.getElementById("riepilogo");
  const attesaDiv = document.getElementById("tempo-attesa");
  const listaPiatti = document.getElementById("lista-piatti");

  if (!ordine) {
    riepilogo.innerHTML = "<p class='err'>Nessun ordine trovato.</p>";
    return;
  }

  // ----- Riepilogo
  const pagamento = ordine.payment || "carta";
  const consegna = ordine.delivery || "-";
  const indirizzo = ordine.delivery === "domicilio" ? (ordine.address || "-") : null;
  riepilogo.innerHTML = `
    <p><strong>Consegna:</strong> ${consegna}</p>
    <p><strong>Metodo di pagamento:</strong> ${pagamento}</p>
    ${indirizzo ? `<p><strong>Indirizzo:</strong> ${indirizzo}</p>` : ""}
  `;

  // ----- Helpers
  const toStr = (v) => (v == null ? null : String(v));
  const clean = (s) => (typeof s === "string" ? s.trim().toLowerCase() : null);

  function normalizeMealDB(p) {
    const id = toStr(p.idmeals ?? p.idMeal ?? p.id ?? p._id);
    const nome = p.nome ?? p.strMeal ?? p.name ?? "Senza nome";
    const prezzo = Number(p.prezzo ?? p.price ?? 0) || 0;
    return { id, nome, prezzo };
  }

  // Estrae elementi ordine in formato {id?, nome?, qty}
  function extractOrderItems(raw) {
    const arr = Array.isArray(raw) ? raw : [];
    return arr.map(x => {
      if (typeof x === "string" || typeof x === "number") {
        return { id: toStr(x), qty: 1 };
      }
      if (x && typeof x === "object") {
        const id = toStr(x.mealId ?? x.idmeals ?? x.idMeal ?? x.id ?? x._id);
        const nome = x.nome ?? x.strMeal ?? x.name ?? x.title ?? null;
        const prezzo = Number(x.prezzo ?? x.price); // se presente nellâ€™ordine lo userÃ²
        const qty = Number(x.qty ?? x.quantity ?? 1) || 1;
        return { id, nome, prezzo, qty };
      }
      return { qty: 0 };
    }).filter(it => it.id || it.nome);
  }

  // Raccogli possibili liste dal payload ordine
  let orderItems = []
    .concat(extractOrderItems(ordine.meals))
    .concat(extractOrderItems(ordine.items))
    .concat(extractOrderItems(ordine.cart))
    .concat(extractOrderItems(ordine.cartItems));

  console.log("DEBUG ordine grezzo:", ordine);
  console.log("DEBUG items estratti:", orderItems);

  // 1) Se negli items ci sono giÃ  nome e (eventuale) prezzo â†’ render immediato
  const alreadyWithNames = orderItems.every(it => !!it.nome);
  if (alreadyWithNames && orderItems.length > 0) {
    let totale = 0;
    listaPiatti.innerHTML = orderItems.map(it => {
      const prezzo = Number(it.prezzo ?? 0) || 0;
      const subtot = prezzo * (it.qty || 1);
      totale += subtot;
      const prezzoTxt = prezzo ? ` â€” â‚¬${subtot.toFixed(2)}` : "";
      return `<li><strong>${it.nome}</strong> Ã— ${it.qty || 1}${prezzoTxt}</li>`;
    }).join("");
    if (totale > 0) {
      const totLi = document.createElement("li");
      totLi.style.marginTop = "8px";
      totLi.innerHTML = `<strong>Totale:</strong> â‚¬${totale.toFixed(2)}`;
      listaPiatti.appendChild(totLi);
    }
  } else {
    // 2) Devo interrogare /meals e matchare
    try {
      const res = await fetch(`${API_BASE}/meals`, { mode: "cors" });
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      const data = await res.json();

      const tuttiIPiatti = Array.isArray(data)
        ? data.flatMap(r => Array.isArray(r.menu) ? r.menu : [])
        : [];

      const catalogo = tuttiIPiatti.map(normalizeMealDB);
      console.log("DEBUG /meals catalogo:", catalogo.slice(0, 5), `(+${Math.max(0, catalogo.length-5)} altri)`);

      // Indici per ID e per NOME (case-insensitive)
      const byId = new Map(catalogo.filter(m => m.id).map(m => [m.id, m]));
      const byName = new Map(catalogo.map(m => [clean(m.nome), m]));

      // Collassa quantitÃ  per id o nome
      const agg = new Map(); // chiave = id o nome normalizzato â†’ {meal, qty}
      for (const it of orderItems) {
        let meal = null;

        // preferisco match per ID se presente
        if (it.id && byId.has(it.id)) {
          meal = byId.get(it.id);
          agg.set(`id:${it.id}`, {
            meal,
            qty: (agg.get(`id:${it.id}`)?.qty || 0) + (it.qty || 1)
          });
          continue;
        }

        // fallback: match per nome se disponibile
        const keyName = clean(it.nome);
        if (keyName && byName.has(keyName)) {
          meal = byName.get(keyName);
          agg.set(`name:${keyName}`, {
            meal,
            qty: (agg.get(`name:${keyName}`)?.qty || 0) + (it.qty || 1)
          });
          continue;
        }
      }

      const righe = [];
      let totale = 0;
      for (const { meal, qty } of agg.values()) {
        const subtot = (meal.prezzo || 0) * qty;
        totale += subtot;
        righe.push(`<li><strong>${meal.nome}</strong> Ã— ${qty} â€” â‚¬${subtot.toFixed(2)}</li>`);
      }

      if (righe.length === 0) {
        // Ultimo fallback: mostra gli ID grezzi per capire cosa sta arrivando
        listaPiatti.innerHTML = `<li>Nessun piatto trovato. (IDs ordine: ${
          orderItems.map(x => x.id || x.nome).join(", ")
        })</li>`;
      } else {
        listaPiatti.innerHTML = righe.join("");
        const totLi = document.createElement("li");
        totLi.style.marginTop = "8px";
        totLi.innerHTML = `<strong>Totale:</strong> â‚¬${totale.toFixed(2)}`;
        listaPiatti.appendChild(totLi);
      }
    } catch (err) {
      console.error("Errore nel caricamento dei piatti:", err);
      listaPiatti.innerHTML = "<li class='err'>Errore nel caricamento dei piatti.</li>";
    }
  }

  // ----- Timer asporto
  if (ordine.delivery === "asporto") {
    try {
      const res = await fetch(`${API_BASE}/orders`, { mode: "cors" });
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      const tuttiGliOrdini = await res.json();

      const ordiniInAttesa = (Array.isArray(tuttiGliOrdini) ? tuttiGliOrdini : []).filter(o =>
        o.delivery === "asporto" && (o.status === "ordinato" || o.status === "preparazione")
      );

      const minutiAttesa = ordiniInAttesa.length * 5;
      let secondiRimanenti = Math.max(0, minutiAttesa * 60);

      const formattaTempo = (s) => {
        const m = Math.floor(s / 60);
        const sec = s % 60;
        return `${m}m ${sec.toString().padStart(2, "0")}s`;
      };

      const aggiornaTimer = () => {
        if (secondiRimanenti > 0) {
          attesaDiv.innerHTML = `
            <p><strong>ðŸ•’ Tempo stimato per il ritiro:</strong> ${formattaTempo(secondiRimanenti)}</p>
          `;
          secondiRimanenti--;
        } else {
          clearInterval(timer);
          attesaDiv.innerHTML = `<p class="ok"><strong>âœ… Il tuo ordine dovrebbe essere pronto!</strong></p>`;
        }
      };

      aggiornaTimer();
      const timer = setInterval(aggiornaTimer, 1000);
    } catch (err) {
      console.error("Errore nel calcolo tempo attesa:", err);
      attesaDiv.innerHTML = "<p class='err'>Errore nel calcolo del tempo di attesa.</p>";
    }
  } else {
    attesaDiv.style.display = "none";
  }
};
</script>

</body>
</html>
