<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8">
  <title>I miei ordini</title>
  <link rel="stylesheet" href="css/style.css">
  <link rel="icon" type="image/png" href="images/logo.png">
</head>
<body>
  <h1>I miei ordini</h1>

  <!-- Riepilogo spese -->
  <div id="summary" class="box" style="padding:12px;border:1px solid #ddd;border-radius:10px;margin:12px 0;">
    <p class="muted">Caricamento riepilogo…</p>
  </div>

  <div id="noti"></div>
  <div id="ordini-container">
    <p>Caricamento…</p>
  </div>

  <p><a href="index.html">Torna alla homepage</a></p>
  <p><a href="storico_clienti.html">Storico ordini</a></p>

  <script src="js/main.js" defer></script>

  <!-- Fallback API_BASE -->
  <script>
  (function () {
    if (!window.API_BASE) {
      const isLocal = ["localhost","127.0.0.1"].includes(location.hostname);
      window.API_BASE = isLocal
        ? "http://localhost:3000"
        : (location.origin || "https://restaurant-management-wzhj.onrender.com");
    }
  })();

  // ---------------- helpers ----------------
  const mealName  = p => p?.nome ?? p?.strMeal ?? p?.name ?? "Piatto";
  const mealPrice = p => Number(p?.prezzo ?? p?.price ?? 0) || 0;
  const mealId    = p => p?.idmeals ?? p?.idMeal ?? p?.id ?? p?._id;
  const orderId   = o => o?.id ?? o?._id ?? "";
  const fmtMoney  = n => `€${Number(n||0).toFixed(2)}`;
  const fmtDate   = iso => { try { return new Date(iso).toLocaleString(); } catch { return ""; } };

  const CLOSED_STATES = ["ritirato","consegnato","annullato","withdrawn","delivered","canceled","cancelled"];
  const isClosedStatus = s => CLOSED_STATES.includes(String(s||"").toLowerCase());

  const labelStatus = s => {
    const t = String(s||"").toLowerCase();
    const map = {
      ordinato: "Ordinato",
      preparazione: "In preparazione",
      consegna: "Pronto al ritiro",
      consegnato: "Consegnato",
      ritirato: "Ritirato",
      annullato: "Annullato",
      withdrawn: "Ritirato",
      delivered: "Consegnato",
      canceled: "Annullato",
      cancelled: "Annullato"
    };
    return map[t] || (s || "Sconosciuto");
  };

  const badgeClass = s => `badge ${String(s||"").toLowerCase()}`;

  // --- Catalogo: costruisci mappa ID -> {name, price}
  function buildMealsMap(raw) {
    const map = new Map();
    const arr = Array.isArray(raw) ? raw : [];
    arr.forEach(node => {
      if (Array.isArray(node?.menu)) {
        node.menu.forEach(p => {
          map.set(String(mealId(p)), { name: mealName(p), price: mealPrice(p) });
        });
      } else {
        const p = node;
        if (p && (mealId(p) != null)) {
          map.set(String(mealId(p)), { name: mealName(p), price: mealPrice(p) });
        }
      }
    });
    return map;
  }

  // ------- helpers per qty/id -------
  const getQty = it => Number(it?.qty ?? it?.quantity ?? it?.quantita ?? it?.q ?? 1) || 1;
  const getItemId = it => it?.mealId ?? it?.idmeal ?? it?.idmeals ?? it?.idMeal ?? it?.id ?? it?._id;

  // TRUE se stringa indica “senza nome”
  const isNoName = s => {
    const t = String(s||"").trim().toLowerCase();
    return !t || t === "senza nome" || t === "unnamed" || t === "dish" || t === "piatto";
  };

  // Costruisce la lista HTML dei piatti e calcola il totale dell'ordine
  function renderItemsAndTotal(ordine, mealsMap) {
    let total = 0;
    let rows = [];

    const pushRow = (name, qty, unitPrice) => {
      const line = unitPrice * qty;
      total += line;
      rows.push(
        `<li>${name} &times;${qty} — <span class="muted">unit</span> ${fmtMoney(unitPrice)} <strong>→ ${fmtMoney(line)}</strong></li>`
      );
    };

    if (Array.isArray(ordine.items) && ordine.items.length) {
      ordine.items.forEach(it => {
        const id  = getItemId(it);
        const cat = id ? mealsMap.get(String(id)) : null;

        let name = it.name ?? it.nome ?? "";
        if (isNoName(name)) name = cat?.name || (id ? `Piatto #${id}` : "Piatto");

        const qty  = getQty(it);
        const unit = Number(it.prezzo ?? it.price ?? cat?.price ?? 0) || 0;

        pushRow(name, qty, unit);
      });
    } else if (Array.isArray(ordine.meals) && ordine.meals.length) {
      ordine.meals.forEach(m => {
        const id  = (typeof m === "object") ? getItemId(m) : m;
        const qty = (typeof m === "object") ? getQty(m) : 1;
        const cat = id != null ? mealsMap.get(String(id)) : null;

        const name  = cat?.name || `Piatto #${id ?? "?"}`;
        const unit  = Number(cat?.price ?? 0) || 0;

        pushRow(name, qty, unit);
      });
    } else {
      // fallback: se l’ordine ha già total salvato
      total = Number(ordine.total) || 0;
      rows = [`<li class="muted">-</li>`];
    }

    return { listHtml: rows.join(""), total };
  }

  // Solo calcolo del totale (riusa le stesse regole)
  function computeTotalForOrder(ord, mealsMap) {
    return renderItemsAndTotal(ord, mealsMap).total;
  }

  // ETA: restituisce {readyAt:Date, remainingMs:number, label:string}
  function getETA(ord) {
    const now = Date.now();
    const state = String(ord?.status ?? ord?.state ?? "").toLowerCase();

    const readyAtISO = ord.readyAt || ord.etaReadyAt || ord.estimatedReadyAt;
    if (readyAtISO) {
      const ra = new Date(readyAtISO).getTime();
      const rem = Math.max(0, ra - now);
      return { readyAt: new Date(ra), remainingMs: rem, label: rem === 0 ? "Pronto al ritiro" : minutesLabel(rem) };
    }

    const mins = Number(ord.prepMinutes || ord.etaMinutes);
    if (!Number.isNaN(mins) && mins > 0) {
      const ra = (new Date(ord.createdAt || Date.now())).getTime() + mins*60000;
      const rem = Math.max(0, ra - now);
      return { readyAt: new Date(ra), remainingMs: rem, label: rem === 0 ? "Pronto al ritiro" : minutesLabel(rem) };
    }

    if (state === "consegna") return { readyAt: new Date(), remainingMs: 0, label: "Pronto al ritiro" };
    const base = (state === "preparazione") ? 10 : 20;
    const ra = (new Date(ord.createdAt || Date.now())).getTime() + base*60000;
    const rem = Math.max(0, ra - now);
    return { readyAt: new Date(ra), remainingMs: rem, label: rem === 0 ? "Pronto al ritiro" : minutesLabel(rem) };
  }

  function minutesLabel(ms) {
    const m = Math.ceil(ms/60000);
    if (m <= 1) return "≈ 1 min";
    if (m <= 5) return "≈ 5 min";
    if (m <= 10) return "≈ 10 min";
    return `≈ ${m} min`;
  }

  // aggiorna periodicamente il countdown
  function startCountdown(span, ordine) {
    const tick = () => {
      const eta = getETA(ordine);
      span.textContent = eta.label;
      span.className = "eta " + (eta.remainingMs === 0 ? "done" : eta.remainingMs <= 10*60000 ? "soon" : "wait");
    };
    tick();
    const id = setInterval(() => {
      if (!span.isConnected) return clearInterval(id);
      tick();
    }, 15000);
  }

  document.addEventListener("DOMContentLoaded", initOrdini);

  async function initOrdini(){
    const user = JSON.parse(localStorage.getItem("loggedUser"));
    if (!user || user.role !== "cliente") {
      alert("Accesso riservato ai clienti");
      location.href = "login.html";
      return;
    }

    const container = document.getElementById("ordini-container");
    const summary   = document.getElementById("summary");
    const noti      = document.getElementById("noti");

    try {
      // 1) ordini del cliente (tutti)
      const res = await fetch(`${API_BASE}/orders?` + new URLSearchParams({ username: user.username }), {
        headers: { "Accept": "application/json" }
      });
      if (!res.ok) throw new Error(`Orders HTTP ${res.status}`);
      const ordini = await res.json();

      // 2) catalogo piatti
      const menuRes = await fetch(`${API_BASE}/meals`, { headers: { "Accept": "application/json" }});
      if (!menuRes.ok) throw new Error(`Meals HTTP ${menuRes.status}`);
      const ristoranti = await menuRes.json();
      const mealsMap = buildMealsMap(ristoranti);

      // ——— Riepilogo spese (tutti gli ordini) ———
      const all = Array.isArray(ordini) ? ordini : [];
      const active = all.filter(o => !isClosedStatus(o?.status ?? o?.state));
      const totalAll   = all.reduce((s,o)    => s + computeTotalForOrder(o, mealsMap), 0);
      const totalAct   = active.reduce((s,o) => s + computeTotalForOrder(o, mealsMap), 0);

      summary.innerHTML = `
        <p><strong>Totale speso (tutti gli ordini):</strong> ${fmtMoney(totalAll)}</p>
        <p><strong>Totale attivo:</strong> ${fmtMoney(totalAct)} — <span class="muted">${active.length} ordini attivi</span></p>
      `;

      // ——— Lista ordini attivi ———
      if (active.length === 0) {
        container.innerHTML = `
          <p>Nessun ordine attivo.</p>
          <p class="muted">Trovi gli ordini ritirati/annullati nello <a href="storico_clienti.html">storico clienti</a>.</p>`;
        return;
      }

      container.innerHTML = "";
      [...active].sort((a,b) => new Date(b.createdAt||0) - new Date(a.createdAt||0))
      .forEach(ordine => {
        const div = document.createElement("div");
        div.className = "ordine-box";

        const { listHtml, total } = renderItemsAndTotal(ordine, mealsMap);
        const idOrd = orderId(ordine);
        const statoRaw = (ordine?.status ?? ordine?.state ?? "Sconosciuto");
        const statoLbl = labelStatus(statoRaw);
        const etaInfo  = getETA(ordine);

        div.innerHTML = `
          <p class="rig"><strong>ID:</strong> ${idOrd || "<span class='muted'>(n/d)</span>"} </p>
          <p class="rig"><strong>Creato:</strong> ${ordine?.createdAt ? fmtDate(ordine.createdAt) : "<span class='muted'>n/d</span>"}</p>
          <p class="rig"><strong>Modalità:</strong> Ritiro in negozio</p>
          <p class="rig"><strong>Stato:</strong> <span class="stato ${badgeClass(statoRaw)}">${statoLbl}</span></p>
          <p class="rig"><strong>Tempo stimato:</strong> <span class="eta">${etaInfo.label}</span></p>
          <p class="rig"><strong>Piatti:</strong></p>
          <ul class="dishes">${listHtml}</ul>
          <p class="rig"><strong>Totale ordine:</strong> ${fmtMoney(total)}</p>
          <div class="actions"></div>
        `;

        startCountdown(div.querySelector(".eta"), ordine);

        // bottone "Ho ritirato l'ordine"
        const actions = div.querySelector(".actions");
        if (idOrd && !isClosedStatus(statoRaw)) {
          const btnPick = document.createElement("button");
          btnPick.textContent = "Ho ritirato l'ordine";
          btnPick.addEventListener("click", async () => {
            const ok = confirm("Confermi di aver ritirato l'ordine al banco?");
            if (!ok) return;
            try {
              const putRes = await fetch(`${API_BASE}/orders/${encodeURIComponent(idOrd)}/state`, {
                method: "PUT",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ newState: "ritirato", clienteConfermaRitiro: true })
              });
              if (!putRes.ok) {
                const detail = await putRes.json().catch(()=>({}));
                throw new Error(`PUT ${putRes.status} ${detail?.error || ""}`);
              }

              // rimuovo la card e aggiorno il riepilogo ricalcolando i totali attivi rimasti
              div.remove();

              const cards = Array.from(container.querySelectorAll(".ordine-box"));
              const newActiveTotal = cards.reduce((sum, el) => sum + Number(el.dataset.total || 0), 0);

              summary.innerHTML = `
                <p><strong>Totale speso (tutti gli ordini):</strong> ${fmtMoney(totalAll)}</p>
                <p><strong>Totale attivo:</strong> ${fmtMoney(newActiveTotal)} — <span class="muted">${cards.length} ordini attivi</span></p>
              `;

              noti.innerHTML = `<p class="success">Ritiro confermato. L'ordine è stato spostato nello <a href="storico_clienti.html"><strong>storico clienti</strong></a>.</p>`;

              if (!container.querySelector(".ordine-box")) {
                container.innerHTML = `
                  <p>Nessun ordine attivo.</p>
                  <p class="muted">Trovi gli ordini ritirati nello <a href="storico_clienti.html">storico clienti</a>.</p>`;
              }
            } catch (err) {
              console.error("Errore conferma ritiro:", err);
              alert("Errore nella conferma del ritiro.");
            }
          });
          actions.appendChild(btnPick);
        }

        // salva totale sulla card per aggiornare il riepilogo al volo
        div.dataset.total = String(total);
        container.appendChild(div);
      });
    } catch (err) {
      console.error("Errore caricamento ordini:", err);
      document.getElementById("ordini-container").innerHTML = `
        <p style="color:#b00">Errore durante il caricamento degli ordini.</p>
        <details><summary>Dettagli</summary><pre>${String(err)}</pre></details>
        <p>Verifica che <code>${API_BASE}/orders</code> e <code>${API_BASE}/meals</code> siano raggiungibili.</p>`;
      document.getElementById("summary").innerHTML = `<p class="err">Impossibile caricare il riepilogo.</p>`;
    }
  }
  </script>
</body>
</html>
